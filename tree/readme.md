###概念
红黑树，是一个每个节点都带有颜色的二叉查找树。   
1.节点都是红色或黑色   
2.根是黑色   
3.所有叶子都是黑色（叶子是nil节点）   
4.每个红色节点必须有两个黑色的子节点（每个叶子到根的路径上不能有两个连续的红色节点）   
5.从任一节点到其每个叶子节点的所有简单路径都包含相同数据的黑色节点

###个人理解
感觉3，4两个限制条件可以修改为3限制条件去掉，4限制条件变更为，红色节点只能没有子节点或者同时拥有两个黑色子节点

###子概念
####二叉查找树，二叉搜索树，二叉排序树
左子树不为空，则左子树上的所有节点值均小于根节点的值
右子树不为空，则右子树上的所有节点值均大于根节点的值

###操作
####添加
参见：https://www.cnblogs.com/skywang12345/p/3245399.html
《红黑树的基本操作(二) 添加》   
基本思路：   
1.新插入节点为根，直接描黑   
2.从跟开始，比较每个树节点和要插入元素；要插入元素大，判断右子树节点和要插入元素关系；要插入元素小，判断左子树节点和要插入元素的关系   
3.最终要插入的元素会位于叶子节点上   
4.插入元素的默认颜色为红色（这样不影响概念中的1，5属性）   
5.新插入节点的父节点为黑色，不用做任何处理   
6.新插入节点的父节点为红色（此时肯定有祖父节点（gp），因为根为黑），   
分情况处理：   
情况一、父节点有红色兄弟节点，操作为将父节点（parent）和父节点的兄弟节点（uncle）颜色设置为黑色，将祖父节点（gp）看为新插入红色节点重新开始插入处理   
情况二、父节点没有兄弟节点，或者父节点的兄弟节点为黑色，先将新插入节点、父节点、祖父节点的管理，通过旋转调整为同为左子（父是gp的左子，捋直）（或同为右子），
再通过右旋（或左旋）将中间节点提升，祖父节点下降，同时修改中间节点的颜色为黑，祖父节点的颜色为红   

####删除（个人处理的删除，与原逻辑不同，原参考地址逻辑没想清楚，不考虑黑节点挂nil节点，黑节点的数目也会保持不变）
基本思路：通过递归删除后继的方式，所有的删除操作最终都会变成一个删除最大右子节点的操作
1.将删除变为，用后继节点的值替换当前删除节点的值，如果没有后继节点则标记父节点的右子为空   
2.如果右子节点的父节点为红色，父节点改为黑色，左子节点改为红色；如果原来是黑色则不用处理

####查找后继节点
右子节点中最小的节点
或父节点中比他大的最小节点

####遍历
